# **[141.Â Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)**

## ë¬¸ì œ

í•œ linked listì˜ headì¸ ì£¼ì–´ì§„ `head`ì— ëŒ€í•´, linked list ë‚´ì— ìˆœí™˜ì´ ìˆëŠ”ì§€ íŒë³„í•˜ë¼.

linked listì— ìˆœí™˜ì´ ìˆë‹¤ëŠ” ê²ƒì€ linked listì—ì„œ `next` í¬ì¸í„°ë¥¼ ê³„ì† ë”°ë¼ê°”ì„ ë•Œ ë‹¤ì‹œ ë„ë‹¬í•˜ê²Œ ë˜ëŠ” nodeê°€ ìˆëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤. ë‚´ë¶€ì ìœ¼ë¡œ, `pos`ëŠ” tail nodeì˜ `next` í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” indexë¥¼ ë‚˜íƒ€ë‚¸ë‹¤. `pos`ëŠ” ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§€ì§€ ì•ŠìŒì— ìœ ì˜í•˜ë¼.

ë§Œì•½ linked listì— ìˆœí™˜ì´ ìˆë‹¤ë©´ `true`ë¥¼, ì•„ë‹ˆë©´ `false`ë¥¼ returní•˜ë¼.

### ì œì•½ ì‚¬í•­

- list ë‚´ node ê°œìˆ˜ ë²”ìœ„ëŠ” `[0, 104]`ì´ë‹¤.
- `-10^5 <= Node.val <= 10^5`
- `pos`ëŠ”Â `-1`Â ì´ê±°ë‚˜ linked list ë‚´ì˜ ìœ íš¨í•œ indexì´ë‹¤.

## ì ‘ê·¼

ì£¼ì–´ì§„ ì •ë³´ê°€ head ë¿ì´ê¸° ë•Œë¬¸ì— ì¼ë‹¨ headì˜ nextë¥¼ ê³„ì† ë”°ë¼ê°€ ë³´ëŠ” ìˆ˜ ë°–ì— ì—†ë‹¤ê³  ìƒê°í–ˆë‹¤. ë°©ë¬¸í•œ headë¥¼ ì €ì¥í•´ë‘ì–´ ì¬ë°©ë¬¸ì¼ ê²½ìš° ë°”ë¡œ trueë¥¼ returní•˜ê³ , nextê°€ nullì„ ê°€ë¦¬í‚¤ë©´ íƒìƒ‰ì„ ì¢…ë£Œí•˜ê³  falseë¥¼ returní•œë‹¤.

### ì˜ì‚¬ ì½”ë“œ

```java
Set<ListNode> ë°©ë¬¸í•œ ë…¸ë“œ set;
ListNode í˜„ì¬ ë…¸ë“œ;
while (í˜„ì¬ ë…¸ë“œ != null) {
	if (setì— í˜„ì¬ ë…¸ë“œ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´) {
		return true;
	}
	setì— í˜„ì¬ ë…¸ë“œ ì €ì¥
	í˜„ì¬ ë…¸ë“œ = ë‹¤ìŒ ë…¸ë“œ
}
return false;
```

## êµ¬í˜„

```java
import java.util.Set;
import java.util.HashSet;

/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {

    public boolean hasCycle(ListNode head) {
        final Set<ListNode> visitedNodes = new HashSet<>();

        ListNode currentNode = head;
        while (currentNode != null) {
            if (visitedNodes.contains(currentNode)) {
                return true;
            }
            visitedNodes.add(currentNode);
            currentNode = currentNode.next;
        }
        return false;
    }
}
```

## Review

- ì‹œê°„ë³µì¡ë„: O(n)
    - HashSetì˜ contains, add O(1)
- ê³µê°„ë³µì¡ë„: O(n)

submití•œ ê²°ê³¼ runtimeì´ `í•˜ìœ„ 15%`ì˜€ë‹¤~!~! ğŸ˜« ì†ë„ë¥¼ ê°œì„ í•˜ê¸° ìœ„í•´ ìœ ëª…í•œ ìˆœí™˜ ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜ `í† ë¼ì™€ ê±°ë¶ì´ ì•Œê³ ë¦¬ì¦˜`ì„ ì ìš©í•´ë´¤ë‹¤.

```java
import java.util.Set;
import java.util.HashSet;

public class Solution {

    public boolean hasCycle(ListNode head) {
        ListNode turtle = head;
        ListNode hare = head;
        while (hare != null && hare.next != null) {
            turtle = turtle.next;
            hare = hare.next.next;
            if (turtle == hare) {
                return true;
            }
        }
        return false;
    }
}
```

ì‹œê°„ë³µì¡ë„ O(N), ê³µê°„ë³µì¡ë„ O(1)ì´ ë˜ì—ˆë‹¤. ê°™ì€ O(N)ì´ì–´ë„ ìˆœí™˜ì´ ì—†ëŠ” ê²½ìš°ì—” ì‹¤í–‰ íšŸìˆ˜ê°€ ì ˆë°˜ìœ¼ë¡œ ì¤€ë‹¤. ìˆœí™˜ì´ ìˆëŠ” ê²½ìš°ì—ë„ ìˆœí™˜ì´ ì‹œì‘ëœ ë…¸ë“œë¡œ ë‹¤ì‹œ ëŒì•„ì˜¤ê¸° ì „ì— ìˆœí™˜ì´ ê²€ì¶œë  ìˆ˜ ìˆì–´ ë” ë¹ ë¥´ë‹¤.

### Floydâ€™s tortoise and hare ì•Œê³ ë¦¬ì¦˜

í”Œë¡œì´ë“œì˜ í† ë¼ì™€ ê±°ë¶ì´ ì•Œê³ ë¦¬ì¦˜ì€ ë‘ ê°œì˜ í¬ì¸í„°ë§Œìœ¼ë¡œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ìˆœí™˜ì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. ì‹œê°„ë³µì¡ë„ O(n), ê³µê°„ë³µì¡ë„ O(1)ì„ ê°€ì§„ë‹¤.

1. ë‘ í¬ì¸í„°ê°€ headì—ì„œ ì¶œë°œ (ê°ê° ê±°ë¶ì´, í† ë¼)
2. ê±°ë¶ì´ëŠ” í•œ ì¹¸ì”©, í† ë¼ëŠ” ë‘ ì¹¸ì”© ì´ë™
    1. ê±°ë¶ì´ì™€ í† ë¼ê°€ ë§Œë‚˜ë©´ ìˆœí™˜ì´ ìˆëŠ” ê²ƒ
    2. í† ë¼ê°€ ë¨¼ì € listì˜ ë§ˆì§€ë§‰ì— ë„ë‹¬í•˜ë©´ ìˆœí™˜ì´ ì—†ëŠ” ê²ƒ

í•µì‹¬ ì›ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤. loopì˜ ê¸¸ì´ë¥¼ `l`, loopê°€ ì‹œì‘ë˜ëŠ” indexë¥¼ `s`, loopê°€ ë°˜ë³µë˜ëŠ” íšŸìˆ˜ë¥¼ `k`, `i`ë²ˆì§¸ì— ë„ë‹¬í•˜ëŠ” ìš”ì†Œì˜ indexë¥¼ `x(i)`ë¼ í•´ë³´ì. `i â‰¥ s` ì¸ `i`ì— ëŒ€í•´ `x(i) = x(i + k * l)`ì„ì´ ì„±ë¦½í•œë‹¤.

`i â‰¥ s`ì´ë©´ì„œ `i = k * l`ì¸ `i`ê°€ ìˆì„ ê²ƒì´ë‹¤. ê·¸ë ‡ë‹¤ë©´ ì´ `i`ì— ëŒ€í•´ì„œëŠ” `x(i) = x(2i)`ì„ì´ ì„±ë¦½í•œë‹¤. ë˜í•œ ìˆœí™˜ì´ ì—†ë‹¤ë©´ `x(i) = x(2i)`ê°€ ì ˆëŒ€ ì„±ë¦½í•  ìˆ˜ ì—†ë‹¤.

ì´ ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•˜ë©´ ìˆœí™˜ì˜ ì¡´ì¬ ì—¬ë¶€ ë¿ ì•„ë‹ˆë¼ ìˆœí™˜ì˜ ì‹œì‘ì ë„ ì°¾ì•„ë‚¼ ìˆ˜ ìˆë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ headë¶€í„° ìˆœí™˜ì˜ ì‹œì‘ì  `s`ê¹Œì§€ ê¸¸ì´ë¥¼ `a`, `s`ë¶€í„° ë‘ í¬ì¸í„°ê°€ ë§Œë‚œ ì§€ì  `p` ê¹Œì§€ì˜ ê¸¸ì´ë¥¼ `b`, `p`ì—ì„œ ë‹¤ì‹œ `s`ë¡œ ëŒì•„ì˜¤ê¸°ê¹Œì§€ì˜ ê¸¸ì´ë¥¼ `c`ë¼ í•˜ì. ê·¸ëŸ¼ ê±°ë¶ì´ê°€ ì›€ì§ì¸ ê±°ë¦¬ëŠ” `a + b`ì´ê³  í† ë¼ëŠ” ë‘ ë°° ë¹ ë¥´ê²Œ ì´ë™í•˜ë‹ˆê¹Œ `2a + 2b`ë§Œí¼ ì›€ì§ì¸ ê²ƒì´ë‹¤. ì´ë²ˆì—” í† ë¼ê°€ ì‹¤ì œë¡œ ì´ë™í•œ ê²½ë¡œë¥¼ ìƒê°í•´ë³´ë©´ `a + b + c`ë¥¼ ê±°ì³ ë‹¤ì‹œ `b`ë§Œí¼ ë” ì›€ì§ì¸ ê²ƒì´ë¯€ë¡œ `a + 2b + c`ì´ë‹¤. `2a + 2b` = `a + 2b + c`ì´ë¯€ë¡œ, `a = c`ì´ë‹¤.

ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ `s`ë¥¼ ì°¾ì•„ë³´ì. ë‘ í¬ì¸í„° ì¤‘ í•˜ë‚˜ë¥¼ headë¡œ ë‹¤ì‹œ ì˜®ê¸´ í›„ ë‘ í¬ì¸í„°ë¥¼ ëª¨ë‘ í•œ ì¹¸ì”© ì´ë™ì‹œì¼°ì„ ë•Œ ë‘ í¬ì¸í„°ê°€ ë§Œë‚˜ëŠ” ì§€ì ì€ ë‘ í¬ì¸í„°ê°€ ê°ê° `a`, `c` ë§Œí¼ ì´ë™í–ˆì„ ë•Œì´ë‹¤. ê·¸ë ‡ë‹¤ë©´ ê·¸ ì§€ì ì´ ë°”ë¡œ `s`ì´ë‹¤.

#### reference

https://en.wikipedia.org/wiki/Cycle_detection#Algorithms
